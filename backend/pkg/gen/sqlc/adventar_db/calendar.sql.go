// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: calendar.sql

package adventar_db

import (
	"context"
	"strings"
)

const createCalendar = `-- name: CreateCalendar :execlastid
INSERT INTO calendars
  (title, description, year, user_id)
VALUES
  (?, ?, ?, ?)
`

type CreateCalendarParams struct {
	Title       string
	Description string
	Year        int32
	UserID      int64
}

func (q *Queries) CreateCalendar(ctx context.Context, arg CreateCalendarParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createCalendar,
		arg.Title,
		arg.Description,
		arg.Year,
		arg.UserID,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const deleteCalendar = `-- name: DeleteCalendar :exec
DELETE FROM
  calendars
WHERE
  id = ?
  AND user_id = ?
`

type DeleteCalendarParams struct {
	ID     int64
	UserID int64
}

func (q *Queries) DeleteCalendar(ctx context.Context, arg DeleteCalendarParams) error {
	_, err := q.db.ExecContext(ctx, deleteCalendar, arg.ID, arg.UserID)
	return err
}

const getCalendarWithUserById = `-- name: GetCalendarWithUserById :one
SELECT
  calendars.id,
  calendars.title,
  calendars.description,
  calendars.year,
  users.id as user_id,
  users.name as user_name,
  users.icon_url as user_icon_url
FROM
  calendars
INNER JOIN
  users ON calendars.user_id = users.id
WHERE
  calendars.id = ?
LIMIT 1
`

type GetCalendarWithUserByIdRow struct {
	ID          int64
	Title       string
	Description string
	Year        int32
	UserID      int64
	UserName    string
	UserIconUrl string
}

func (q *Queries) GetCalendarWithUserById(ctx context.Context, id int64) (GetCalendarWithUserByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getCalendarWithUserById, id)
	var i GetCalendarWithUserByIdRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Year,
		&i.UserID,
		&i.UserName,
		&i.UserIconUrl,
	)
	return i, err
}

const getEntryCountByCalendarId = `-- name: GetEntryCountByCalendarId :many
SELECT
  calendar_id,
  count(*) as count
FROM
  entries
WHERE
  calendar_id IN (/*SLICE:ids*/?)
GROUP BY
  calendar_id
`

type GetEntryCountByCalendarIdRow struct {
	CalendarID int64
	Count      int64
}

func (q *Queries) GetEntryCountByCalendarId(ctx context.Context, ids []int64) ([]GetEntryCountByCalendarIdRow, error) {
	sql := getEntryCountByCalendarId
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		sql = strings.Replace(sql, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, sql, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEntryCountByCalendarIdRow
	for rows.Next() {
		var i GetEntryCountByCalendarIdRow
		if err := rows.Scan(&i.CalendarID, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllCalendars = `-- name: ListAllCalendars :many
SELECT
  calendars.id,
  calendars.title,
  calendars.description,
  calendars.year,
  users.id as user_id,
  users.name as user_name,
  users.icon_url as user_icon_url
FROM
  calendars
INNER JOIN
  users ON calendars.user_id = users.id
WHERE
  year = ?
  AND listable = true
ORDER BY
  calendars.id DESC
`

type ListAllCalendarsRow struct {
	ID          int64
	Title       string
	Description string
	Year        int32
	UserID      int64
	UserName    string
	UserIconUrl string
}

func (q *Queries) ListAllCalendars(ctx context.Context, year int32) ([]ListAllCalendarsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllCalendars, year)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllCalendarsRow
	for rows.Next() {
		var i ListAllCalendarsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Year,
			&i.UserID,
			&i.UserName,
			&i.UserIconUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCalendarStats = `-- name: ListCalendarStats :many
SELECT
  year
  , count(distinct calendars.id) AS calendars_count
  , count(entries.id) AS entries_count
FROM
  calendars
  LEFT JOIN entries ON entries.calendar_id = calendars.id
GROUP BY
  year
ORDER BY
  year DESC
`

type ListCalendarStatsRow struct {
	Year           int32
	CalendarsCount int64
	EntriesCount   int64
}

func (q *Queries) ListCalendarStats(ctx context.Context) ([]ListCalendarStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, listCalendarStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCalendarStatsRow
	for rows.Next() {
		var i ListCalendarStatsRow
		if err := rows.Scan(&i.Year, &i.CalendarsCount, &i.EntriesCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCalendars = `-- name: ListCalendars :many
SELECT
  calendars.id,
  calendars.title,
  calendars.description,
  calendars.year,
  users.id as user_id,
  users.name as user_name,
  users.icon_url as user_icon_url
FROM
  calendars
INNER JOIN
  users ON calendars.user_id = users.id
WHERE
  year = ?
  AND listable = true
ORDER BY
  calendars.id DESC
LIMIT ?
`

type ListCalendarsParams struct {
	Year  int32
	Limit int32
}

type ListCalendarsRow struct {
	ID          int64
	Title       string
	Description string
	Year        int32
	UserID      int64
	UserName    string
	UserIconUrl string
}

func (q *Queries) ListCalendars(ctx context.Context, arg ListCalendarsParams) ([]ListCalendarsRow, error) {
	rows, err := q.db.QueryContext(ctx, listCalendars, arg.Year, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCalendarsRow
	for rows.Next() {
		var i ListCalendarsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Year,
			&i.UserID,
			&i.UserName,
			&i.UserIconUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCalendarsByUserId = `-- name: ListCalendarsByUserId :many
SELECT
  calendars.id,
  calendars.title,
  calendars.description,
  calendars.year,
  users.id as user_id,
  users.name as user_name,
  users.icon_url as user_icon_url
FROM
  calendars
INNER JOIN
  users ON calendars.user_id = users.id
WHERE
  year = ?
  AND users.id = ?
ORDER BY
  calendars.id DESC
`

type ListCalendarsByUserIdParams struct {
	Year int32
	ID   int64
}

type ListCalendarsByUserIdRow struct {
	ID          int64
	Title       string
	Description string
	Year        int32
	UserID      int64
	UserName    string
	UserIconUrl string
}

func (q *Queries) ListCalendarsByUserId(ctx context.Context, arg ListCalendarsByUserIdParams) ([]ListCalendarsByUserIdRow, error) {
	rows, err := q.db.QueryContext(ctx, listCalendarsByUserId, arg.Year, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCalendarsByUserIdRow
	for rows.Next() {
		var i ListCalendarsByUserIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Year,
			&i.UserID,
			&i.UserName,
			&i.UserIconUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCalendars = `-- name: SearchCalendars :many
SELECT
  calendars.id,
  calendars.title,
  calendars.description,
  calendars.year,
  users.id as user_id,
  users.name as user_name,
  users.icon_url as user_icon_url
FROM
  calendars
INNER JOIN
  users ON calendars.user_id = users.id
WHERE
  year = ?
  AND listable = true
  AND (calendars.title LIKE ? OR calendars.description LIKE ?)
ORDER BY
  calendars.id DESC
`

type SearchCalendarsParams struct {
	Year    int32
	Keyword string
}

type SearchCalendarsRow struct {
	ID          int64
	Title       string
	Description string
	Year        int32
	UserID      int64
	UserName    string
	UserIconUrl string
}

func (q *Queries) SearchCalendars(ctx context.Context, arg SearchCalendarsParams) ([]SearchCalendarsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchCalendars, arg.Year, arg.Keyword, arg.Keyword)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchCalendarsRow
	for rows.Next() {
		var i SearchCalendarsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Year,
			&i.UserID,
			&i.UserName,
			&i.UserIconUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCalendar = `-- name: UpdateCalendar :exec
UPDATE
  calendars
SET
  title = ?,
  description = ?
WHERE
  id = ?
  AND user_id = ?
`

type UpdateCalendarParams struct {
	Title       string
	Description string
	ID          int64
	UserID      int64
}

func (q *Queries) UpdateCalendar(ctx context.Context, arg UpdateCalendarParams) error {
	_, err := q.db.ExecContext(ctx, updateCalendar,
		arg.Title,
		arg.Description,
		arg.ID,
		arg.UserID,
	)
	return err
}
